import {
  require_eventemitter3,
  require_immutable,
  require_lib,
  require_parse_mapbox_token
} from "./chunk-DOQ7I7SS.js";
import {
  __commonJS
} from "./chunk-NIBQISYW.js";

// node_modules/@mapbox/mapbox-sdk/services/service-helpers/validator.js
var require_validator = __commonJS({
  "node_modules/@mapbox/mapbox-sdk/services/service-helpers/validator.js"(exports, module) {
    "use strict";
    var xtend = require_immutable();
    var v = require_lib();
    function file(value) {
      if (typeof window !== "undefined") {
        if (value instanceof global.Blob || value instanceof global.ArrayBuffer) {
          return;
        }
        return "Blob or ArrayBuffer";
      }
      if (typeof value === "string" || value.pipe !== void 0) {
        return;
      }
      return "Filename or Readable stream";
    }
    function assertShape(validatorObj, apiName) {
      return v.assert(v.strictShape(validatorObj), apiName);
    }
    function date(value) {
      var msg = "date";
      if (typeof value === "boolean") {
        return msg;
      }
      try {
        var date2 = new Date(value);
        if (date2.getTime && isNaN(date2.getTime())) {
          return msg;
        }
      } catch (e) {
        return msg;
      }
    }
    function coordinates(value) {
      return v.tuple(v.number, v.number)(value);
    }
    module.exports = xtend(v, {
      file,
      date,
      coordinates,
      assertShape
    });
  }
});

// node_modules/@mapbox/mapbox-sdk/services/service-helpers/pick.js
var require_pick = __commonJS({
  "node_modules/@mapbox/mapbox-sdk/services/service-helpers/pick.js"(exports, module) {
    "use strict";
    function pick(source, keys) {
      var filter = function(key, val) {
        return keys.indexOf(key) !== -1 && val !== void 0;
      };
      if (typeof keys === "function") {
        filter = keys;
      }
      return Object.keys(source).filter(function(key) {
        return filter(key, source[key]);
      }).reduce(function(result, key) {
        result[key] = source[key];
        return result;
      }, {});
    }
    module.exports = pick;
  }
});

// node_modules/@mapbox/mapbox-sdk/lib/helpers/url-utils.js
var require_url_utils = __commonJS({
  "node_modules/@mapbox/mapbox-sdk/lib/helpers/url-utils.js"(exports, module) {
    "use strict";
    function encodeArray(arrayValue) {
      return arrayValue.map(encodeURIComponent).join(",");
    }
    function encodeValue(value) {
      if (Array.isArray(value)) {
        return encodeArray(value);
      }
      return encodeURIComponent(String(value));
    }
    function appendQueryParam(url, key, value) {
      if (value === false || value === null) {
        return url;
      }
      var punctuation = /\?/.test(url) ? "&" : "?";
      var query = encodeURIComponent(key);
      if (value !== void 0 && value !== "" && value !== true) {
        query += "=" + encodeValue(value);
      }
      return "" + url + punctuation + query;
    }
    function appendQueryObject(url, queryObject) {
      if (!queryObject) {
        return url;
      }
      var result = url;
      Object.keys(queryObject).forEach(function(key) {
        var value = queryObject[key];
        if (value === void 0) {
          return;
        }
        if (Array.isArray(value)) {
          value = value.filter(function(v) {
            return v !== null && v !== void 0;
          }).join(",");
        }
        result = appendQueryParam(result, key, value);
      });
      return result;
    }
    function prependOrigin(url, origin) {
      if (!origin) {
        return url;
      }
      if (url.slice(0, 4) === "http") {
        return url;
      }
      var delimiter = url[0] === "/" ? "" : "/";
      return "" + origin.replace(/\/$/, "") + delimiter + url;
    }
    function interpolateRouteParams(route, params) {
      if (!params) {
        return route;
      }
      return route.replace(/\/:([a-zA-Z0-9]+)/g, function(_, paramId) {
        var value = params[paramId];
        if (value === void 0) {
          throw new Error("Unspecified route parameter " + paramId);
        }
        var preppedValue = encodeValue(value);
        return "/" + preppedValue;
      });
    }
    module.exports = {
      appendQueryObject,
      appendQueryParam,
      prependOrigin,
      interpolateRouteParams
    };
  }
});

// node_modules/@mapbox/mapbox-sdk/lib/constants.js
var require_constants = __commonJS({
  "node_modules/@mapbox/mapbox-sdk/lib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      API_ORIGIN: "https://api.mapbox.com",
      EVENT_PROGRESS_DOWNLOAD: "downloadProgress",
      EVENT_PROGRESS_UPLOAD: "uploadProgress",
      EVENT_ERROR: "error",
      EVENT_RESPONSE: "response",
      ERROR_HTTP: "HttpError",
      ERROR_REQUEST_ABORTED: "RequestAbortedError"
    };
  }
});

// node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-request.js
var require_mapi_request = __commonJS({
  "node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-request.js"(exports, module) {
    "use strict";
    var parseToken = require_parse_mapbox_token();
    var xtend = require_immutable();
    var EventEmitter = require_eventemitter3();
    var urlUtils = require_url_utils();
    var constants = require_constants();
    var requestId = 1;
    function MapiRequest(client, options) {
      if (!client) {
        throw new Error("MapiRequest requires a client");
      }
      if (!options || !options.path || !options.method) {
        throw new Error(
          "MapiRequest requires an options object with path and method properties"
        );
      }
      var defaultHeaders = {};
      if (options.body) {
        defaultHeaders["content-type"] = "application/json";
      }
      var headersWithDefaults = xtend(defaultHeaders, options.headers);
      var headers = Object.keys(headersWithDefaults).reduce(function(memo, name) {
        memo[name.toLowerCase()] = headersWithDefaults[name];
        return memo;
      }, {});
      this.id = requestId++;
      this._options = options;
      this.emitter = new EventEmitter();
      this.client = client;
      this.response = null;
      this.error = null;
      this.sent = false;
      this.aborted = false;
      this.path = options.path;
      this.method = options.method;
      this.origin = options.origin || client.origin;
      this.query = options.query || {};
      this.params = options.params || {};
      this.body = options.body || null;
      this.file = options.file || null;
      this.encoding = options.encoding || "utf8";
      this.sendFileAs = options.sendFileAs || null;
      this.headers = headers;
    }
    MapiRequest.prototype.url = function url(accessToken) {
      var url2 = urlUtils.prependOrigin(this.path, this.origin);
      url2 = urlUtils.appendQueryObject(url2, this.query);
      var routeParams = this.params;
      var actualAccessToken = accessToken == null ? this.client.accessToken : accessToken;
      if (actualAccessToken) {
        url2 = urlUtils.appendQueryParam(url2, "access_token", actualAccessToken);
        var accessTokenOwnerId = parseToken(actualAccessToken).user;
        routeParams = xtend({ ownerId: accessTokenOwnerId }, routeParams);
      }
      url2 = urlUtils.interpolateRouteParams(url2, routeParams);
      return url2;
    };
    MapiRequest.prototype.send = function send() {
      var self = this;
      if (self.sent) {
        throw new Error(
          "This request has already been sent. Check the response and error properties. Create a new request with clone()."
        );
      }
      self.sent = true;
      return self.client.sendRequest(self).then(
        function(response) {
          self.response = response;
          self.emitter.emit(constants.EVENT_RESPONSE, response);
          return response;
        },
        function(error) {
          self.error = error;
          self.emitter.emit(constants.EVENT_ERROR, error);
          throw error;
        }
      );
    };
    MapiRequest.prototype.abort = function abort() {
      if (this._nextPageRequest) {
        this._nextPageRequest.abort();
        delete this._nextPageRequest;
      }
      if (this.response || this.error || this.aborted)
        return;
      this.aborted = true;
      this.client.abortRequest(this);
    };
    MapiRequest.prototype.eachPage = function eachPage(callback) {
      var self = this;
      function handleResponse(response) {
        function getNextPage() {
          delete self._nextPageRequest;
          var nextPageRequest = response.nextPage();
          if (nextPageRequest) {
            self._nextPageRequest = nextPageRequest;
            getPage(nextPageRequest);
          }
        }
        callback(null, response, getNextPage);
      }
      function handleError(error) {
        callback(error, null, function() {
        });
      }
      function getPage(request) {
        request.send().then(handleResponse, handleError);
      }
      getPage(this);
    };
    MapiRequest.prototype.clone = function clone() {
      return this._extend();
    };
    MapiRequest.prototype._extend = function _extend(options) {
      var extendedOptions = xtend(this._options, options);
      return new MapiRequest(this.client, extendedOptions);
    };
    module.exports = MapiRequest;
  }
});

// node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-client.js
var require_mapi_client = __commonJS({
  "node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-client.js"(exports, module) {
    "use strict";
    var parseToken = require_parse_mapbox_token();
    var MapiRequest = require_mapi_request();
    var constants = require_constants();
    function MapiClient(options) {
      if (!options || !options.accessToken) {
        throw new Error("Cannot create a client without an access token");
      }
      parseToken(options.accessToken);
      this.accessToken = options.accessToken;
      this.origin = options.origin || constants.API_ORIGIN;
    }
    MapiClient.prototype.createRequest = function createRequest(requestOptions) {
      return new MapiRequest(this, requestOptions);
    };
    module.exports = MapiClient;
  }
});

// node_modules/@mapbox/mapbox-sdk/lib/helpers/parse-link-header.js
var require_parse_link_header = __commonJS({
  "node_modules/@mapbox/mapbox-sdk/lib/helpers/parse-link-header.js"(exports, module) {
    "use strict";
    function parseParam(param) {
      var parts = param.match(/\s*(.+)\s*=\s*"?([^"]+)"?/);
      if (!parts)
        return null;
      return {
        key: parts[1],
        value: parts[2]
      };
    }
    function parseLink(link) {
      var parts = link.match(/<?([^>]*)>(.*)/);
      if (!parts)
        return null;
      var linkUrl = parts[1];
      var linkParams = parts[2].split(";");
      var rel = null;
      var parsedLinkParams = linkParams.reduce(function(result, param) {
        var parsed = parseParam(param);
        if (!parsed)
          return result;
        if (parsed.key === "rel") {
          if (!rel) {
            rel = parsed.value;
          }
          return result;
        }
        result[parsed.key] = parsed.value;
        return result;
      }, {});
      if (!rel)
        return null;
      return {
        url: linkUrl,
        rel,
        params: parsedLinkParams
      };
    }
    function parseLinkHeader(linkHeader) {
      if (!linkHeader)
        return {};
      return linkHeader.split(/,\s*</).reduce(function(result, link) {
        var parsed = parseLink(link);
        if (!parsed)
          return result;
        var splitRel = parsed.rel.split(/\s+/);
        splitRel.forEach(function(rel) {
          if (!result[rel]) {
            result[rel] = {
              url: parsed.url,
              params: parsed.params
            };
          }
        });
        return result;
      }, {});
    }
    module.exports = parseLinkHeader;
  }
});

// node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-response.js
var require_mapi_response = __commonJS({
  "node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-response.js"(exports, module) {
    "use strict";
    var parseLinkHeader = require_parse_link_header();
    function MapiResponse(request, responseData) {
      this.request = request;
      this.headers = responseData.headers;
      this.rawBody = responseData.body;
      this.statusCode = responseData.statusCode;
      try {
        this.body = JSON.parse(responseData.body || "{}");
      } catch (parseError) {
        this.body = responseData.body;
      }
      this.links = parseLinkHeader(this.headers.link);
    }
    MapiResponse.prototype.hasNextPage = function hasNextPage() {
      return !!this.links.next;
    };
    MapiResponse.prototype.nextPage = function nextPage() {
      if (!this.hasNextPage())
        return null;
      return this.request._extend({
        path: this.links.next.url
      });
    };
    module.exports = MapiResponse;
  }
});

// node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-error.js
var require_mapi_error = __commonJS({
  "node_modules/@mapbox/mapbox-sdk/lib/classes/mapi-error.js"(exports, module) {
    "use strict";
    var constants = require_constants();
    function MapiError(options) {
      var errorType = options.type || constants.ERROR_HTTP;
      var body;
      if (options.body) {
        try {
          body = JSON.parse(options.body);
        } catch (e) {
          body = options.body;
        }
      } else {
        body = null;
      }
      var message = options.message || null;
      if (!message) {
        if (typeof body === "string") {
          message = body;
        } else if (body && typeof body.message === "string") {
          message = body.message;
        } else if (errorType === constants.ERROR_REQUEST_ABORTED) {
          message = "Request aborted";
        }
      }
      this.message = message;
      this.type = errorType;
      this.statusCode = options.statusCode || null;
      this.request = options.request;
      this.body = body;
    }
    module.exports = MapiError;
  }
});

// node_modules/@mapbox/mapbox-sdk/lib/helpers/parse-headers.js
var require_parse_headers = __commonJS({
  "node_modules/@mapbox/mapbox-sdk/lib/helpers/parse-headers.js"(exports, module) {
    "use strict";
    function parseSingleHeader(raw) {
      var boundary = raw.indexOf(":");
      var name = raw.substring(0, boundary).trim().toLowerCase();
      var value = raw.substring(boundary + 1).trim();
      return {
        name,
        value
      };
    }
    function parseHeaders(raw) {
      var headers = {};
      if (!raw) {
        return headers;
      }
      raw.trim().split(/[\r|\n]+/).forEach(function(rawHeader) {
        var parsed = parseSingleHeader(rawHeader);
        headers[parsed.name] = parsed.value;
      });
      return headers;
    }
    module.exports = parseHeaders;
  }
});

// node_modules/@mapbox/mapbox-sdk/lib/browser/browser-layer.js
var require_browser_layer = __commonJS({
  "node_modules/@mapbox/mapbox-sdk/lib/browser/browser-layer.js"(exports, module) {
    "use strict";
    var MapiResponse = require_mapi_response();
    var MapiError = require_mapi_error();
    var constants = require_constants();
    var parseHeaders = require_parse_headers();
    var requestsUnderway = {};
    function browserAbort(request) {
      var xhr = requestsUnderway[request.id];
      if (!xhr)
        return;
      xhr.abort();
      delete requestsUnderway[request.id];
    }
    function createResponse(request, xhr) {
      return new MapiResponse(request, {
        body: xhr.response,
        headers: parseHeaders(xhr.getAllResponseHeaders()),
        statusCode: xhr.status
      });
    }
    function normalizeBrowserProgressEvent(event) {
      var total = event.total;
      var transferred = event.loaded;
      var percent = 100 * transferred / total;
      return {
        total,
        transferred,
        percent
      };
    }
    function sendRequestXhr(request, xhr) {
      return new Promise(function(resolve, reject) {
        xhr.onprogress = function(event) {
          request.emitter.emit(
            constants.EVENT_PROGRESS_DOWNLOAD,
            normalizeBrowserProgressEvent(event)
          );
        };
        var file = request.file;
        if (file) {
          xhr.upload.onprogress = function(event) {
            request.emitter.emit(
              constants.EVENT_PROGRESS_UPLOAD,
              normalizeBrowserProgressEvent(event)
            );
          };
        }
        xhr.onerror = function(error) {
          reject(error);
        };
        xhr.onabort = function() {
          var mapiError = new MapiError({
            request,
            type: constants.ERROR_REQUEST_ABORTED
          });
          reject(mapiError);
        };
        xhr.onload = function() {
          delete requestsUnderway[request.id];
          if (xhr.status < 200 || xhr.status >= 400) {
            var mapiError = new MapiError({
              request,
              body: xhr.response,
              statusCode: xhr.status
            });
            reject(mapiError);
            return;
          }
          resolve(xhr);
        };
        var body = request.body;
        if (typeof body === "string") {
          xhr.send(body);
        } else if (body) {
          xhr.send(JSON.stringify(body));
        } else if (file) {
          xhr.send(file);
        } else {
          xhr.send();
        }
        requestsUnderway[request.id] = xhr;
      }).then(function(xhr2) {
        return createResponse(request, xhr2);
      });
    }
    function createRequestXhr(request, accessToken) {
      var url = request.url(accessToken);
      var xhr = new window.XMLHttpRequest();
      xhr.open(request.method, url);
      Object.keys(request.headers).forEach(function(key) {
        xhr.setRequestHeader(key, request.headers[key]);
      });
      return xhr;
    }
    function browserSend(request) {
      return Promise.resolve().then(function() {
        var xhr = createRequestXhr(request, request.client.accessToken);
        return sendRequestXhr(request, xhr);
      });
    }
    module.exports = {
      browserAbort,
      sendRequestXhr,
      browserSend,
      createRequestXhr
    };
  }
});

// node_modules/@mapbox/mapbox-sdk/lib/browser/browser-client.js
var require_browser_client = __commonJS({
  "node_modules/@mapbox/mapbox-sdk/lib/browser/browser-client.js"(exports, module) {
    "use strict";
    var browser = require_browser_layer();
    var MapiClient = require_mapi_client();
    function BrowserClient(options) {
      MapiClient.call(this, options);
    }
    BrowserClient.prototype = Object.create(MapiClient.prototype);
    BrowserClient.prototype.constructor = BrowserClient;
    BrowserClient.prototype.sendRequest = browser.browserSend;
    BrowserClient.prototype.abortRequest = browser.browserAbort;
    function createBrowserClient(options) {
      return new BrowserClient(options);
    }
    module.exports = createBrowserClient;
  }
});

// node_modules/@mapbox/mapbox-sdk/services/service-helpers/create-service-factory.js
var require_create_service_factory = __commonJS({
  "node_modules/@mapbox/mapbox-sdk/services/service-helpers/create-service-factory.js"(exports, module) {
    "use strict";
    var MapiClient = require_mapi_client();
    var createClient = require_browser_client();
    function createServiceFactory(ServicePrototype) {
      return function(clientOrConfig) {
        var client;
        if (MapiClient.prototype.isPrototypeOf(clientOrConfig)) {
          client = clientOrConfig;
        } else {
          client = createClient(clientOrConfig);
        }
        var service = Object.create(ServicePrototype);
        service.client = client;
        return service;
      };
    }
    module.exports = createServiceFactory;
  }
});

// node_modules/@mapbox/mapbox-sdk/services/datasets.js
var require_datasets = __commonJS({
  "node_modules/@mapbox/mapbox-sdk/services/datasets.js"(exports, module) {
    var v = require_validator();
    var pick = require_pick();
    var createServiceFactory = require_create_service_factory();
    var Datasets = {};
    Datasets.listDatasets = function(config) {
      v.assertShape({
        sortby: v.oneOf("created", "modified")
      })(config);
      return this.client.createRequest({
        method: "GET",
        path: "/datasets/v1/:ownerId",
        query: config ? pick(config, ["sortby"]) : {}
      });
    };
    Datasets.createDataset = function(config) {
      v.assertShape({
        name: v.string,
        description: v.string
      })(config);
      return this.client.createRequest({
        method: "POST",
        path: "/datasets/v1/:ownerId",
        body: config
      });
    };
    Datasets.getMetadata = function(config) {
      v.assertShape({
        datasetId: v.required(v.string),
        description: v.string
      })(config);
      return this.client.createRequest({
        method: "GET",
        path: "/datasets/v1/:ownerId/:datasetId",
        params: config
      });
    };
    Datasets.updateMetadata = function(config) {
      v.assertShape({
        datasetId: v.required(v.string),
        name: v.string,
        description: v.string
      })(config);
      return this.client.createRequest({
        method: "PATCH",
        path: "/datasets/v1/:ownerId/:datasetId",
        params: pick(config, ["datasetId"]),
        body: pick(config, ["name", "description"])
      });
    };
    Datasets.deleteDataset = function(config) {
      v.assertShape({
        datasetId: v.required(v.string)
      })(config);
      return this.client.createRequest({
        method: "DELETE",
        path: "/datasets/v1/:ownerId/:datasetId",
        params: config
      });
    };
    Datasets.listFeatures = function(config) {
      v.assertShape({
        datasetId: v.required(v.string),
        limit: v.number,
        start: v.string
      })(config);
      return this.client.createRequest({
        method: "GET",
        path: "/datasets/v1/:ownerId/:datasetId/features",
        params: pick(config, ["datasetId"]),
        query: pick(config, ["limit", "start"])
      });
    };
    Datasets.putFeature = function(config) {
      v.assertShape({
        datasetId: v.required(v.string),
        featureId: v.required(v.string),
        feature: v.required(v.plainObject)
      })(config);
      if (config.feature.id !== void 0 && config.feature.id !== config.featureId) {
        throw new Error("featureId must match the id property of the feature");
      }
      return this.client.createRequest({
        method: "PUT",
        path: "/datasets/v1/:ownerId/:datasetId/features/:featureId",
        params: pick(config, ["datasetId", "featureId"]),
        body: config.feature
      });
    };
    Datasets.getFeature = function(config) {
      v.assertShape({
        datasetId: v.required(v.string),
        featureId: v.required(v.string)
      })(config);
      return this.client.createRequest({
        method: "GET",
        path: "/datasets/v1/:ownerId/:datasetId/features/:featureId",
        params: config
      });
    };
    Datasets.deleteFeature = function(config) {
      v.assertShape({
        datasetId: v.required(v.string),
        featureId: v.required(v.string)
      })(config);
      return this.client.createRequest({
        method: "DELETE",
        path: "/datasets/v1/:ownerId/:datasetId/features/:featureId",
        params: config
      });
    };
    module.exports = createServiceFactory(Datasets);
  }
});
export default require_datasets();
//# sourceMappingURL=@mapbox_mapbox-sdk_services_datasets.js.map
