import {
  __commonJS
} from "./chunk-NIBQISYW.js";

// node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "node_modules/xtend/immutable.js"(exports, module) {
    module.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "node_modules/is-plain-obj/index.js"(exports, module) {
    "use strict";
    var toString = Object.prototype.toString;
    module.exports = function(x) {
      var prototype;
      return toString.call(x) === "[object Object]" && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
    };
  }
});

// node_modules/@mapbox/fusspot/lib/index.js
var require_lib = __commonJS({
  "node_modules/@mapbox/fusspot/lib/index.js"(exports, module) {
    "use strict";
    var isPlainObject = require_is_plain_obj();
    var xtend = require_immutable();
    var DEFAULT_ERROR_PATH = "value";
    var NEWLINE_INDENT = "\n  ";
    var v = {};
    v.assert = function(rootValidator, options) {
      options = options || {};
      return function(value) {
        var message = validate(rootValidator, value);
        if (!message) {
          return;
        }
        var errorMessage = processMessage(message, options);
        if (options.apiName) {
          errorMessage = options.apiName + ": " + errorMessage;
        }
        throw new Error(errorMessage);
      };
    };
    v.shape = function shape(validatorObj) {
      var validators = objectEntries(validatorObj);
      return function shapeValidator(value) {
        var validationResult = validate(v.plainObject, value);
        if (validationResult) {
          return validationResult;
        }
        var key, validator;
        var errorMessages = [];
        for (var i = 0; i < validators.length; i++) {
          key = validators[i].key;
          validator = validators[i].value;
          validationResult = validate(validator, value[key]);
          if (validationResult) {
            errorMessages.push([key].concat(validationResult));
          }
        }
        if (errorMessages.length < 2) {
          return errorMessages[0];
        }
        return function(options) {
          errorMessages = errorMessages.map(function(message) {
            var key2 = message[0];
            var renderedMessage = processMessage(message, options).split("\n").join(NEWLINE_INDENT);
            return "- " + key2 + ": " + renderedMessage;
          });
          var objectId = options.path.join(".");
          var ofPhrase = objectId === DEFAULT_ERROR_PATH ? "" : " of " + objectId;
          return "The following properties" + ofPhrase + " have invalid values:" + NEWLINE_INDENT + errorMessages.join(NEWLINE_INDENT);
        };
      };
    };
    v.strictShape = function strictShape(validatorObj) {
      var shapeValidator = v.shape(validatorObj);
      return function strictShapeValidator(value) {
        var shapeResult = shapeValidator(value);
        if (shapeResult) {
          return shapeResult;
        }
        var invalidKeys = Object.keys(value).reduce(function(memo, valueKey) {
          if (validatorObj[valueKey] === void 0) {
            memo.push(valueKey);
          }
          return memo;
        }, []);
        if (invalidKeys.length !== 0) {
          return function() {
            return "The following keys are invalid: " + invalidKeys.join(", ");
          };
        }
      };
    };
    v.arrayOf = function arrayOf(validator) {
      return createArrayValidator(validator);
    };
    v.tuple = function tuple() {
      var validators = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);
      return createArrayValidator(validators);
    };
    function createArrayValidator(validators) {
      var validatingTuple = Array.isArray(validators);
      var getValidator = function(index) {
        if (validatingTuple) {
          return validators[index];
        }
        return validators;
      };
      return function arrayValidator(value) {
        var validationResult = validate(v.plainArray, value);
        if (validationResult) {
          return validationResult;
        }
        if (validatingTuple && value.length !== validators.length) {
          return "an array with " + validators.length + " items";
        }
        for (var i = 0; i < value.length; i++) {
          validationResult = validate(getValidator(i), value[i]);
          if (validationResult) {
            return [i].concat(validationResult);
          }
        }
      };
    }
    v.required = function required(validator) {
      function requiredValidator(value) {
        if (value == null) {
          return function(options) {
            return formatErrorMessage(
              options,
              isArrayCulprit(options.path) ? "cannot be undefined/null." : "is required."
            );
          };
        }
        return validator.apply(this, arguments);
      }
      requiredValidator.__required = true;
      return requiredValidator;
    };
    v.oneOfType = function oneOfType() {
      var validators = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);
      return function oneOfTypeValidator(value) {
        var messages = validators.map(function(validator) {
          return validate(validator, value);
        }).filter(Boolean);
        if (messages.length !== validators.length) {
          return;
        }
        if (messages.every(function(message) {
          return message.length === 1 && typeof message[0] === "string";
        })) {
          return orList(
            messages.map(function(m) {
              return m[0];
            })
          );
        }
        return messages.reduce(function(max, arr) {
          return arr.length > max.length ? arr : max;
        });
      };
    };
    v.equal = function equal(compareWith) {
      return function equalValidator(value) {
        if (value !== compareWith) {
          return JSON.stringify(compareWith);
        }
      };
    };
    v.oneOf = function oneOf() {
      var options = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);
      var validators = options.map(function(value) {
        return v.equal(value);
      });
      return v.oneOfType.apply(this, validators);
    };
    v.range = function range(compareWith) {
      var min = compareWith[0];
      var max = compareWith[1];
      return function rangeValidator(value) {
        var validationResult = validate(v.number, value);
        if (validationResult || value < min || value > max) {
          return "number between " + min + " & " + max + " (inclusive)";
        }
      };
    };
    v.any = function any() {
      return;
    };
    v.boolean = function boolean(value) {
      if (typeof value !== "boolean") {
        return "boolean";
      }
    };
    v.number = function number(value) {
      if (typeof value !== "number") {
        return "number";
      }
    };
    v.plainArray = function plainArray(value) {
      if (!Array.isArray(value)) {
        return "array";
      }
    };
    v.plainObject = function plainObject(value) {
      if (!isPlainObject(value)) {
        return "object";
      }
    };
    v.string = function string(value) {
      if (typeof value !== "string") {
        return "string";
      }
    };
    v.func = function func(value) {
      if (typeof value !== "function") {
        return "function";
      }
    };
    function validate(validator, value) {
      if (value == null && !validator.hasOwnProperty("__required")) {
        return;
      }
      var result = validator(value);
      if (result) {
        return Array.isArray(result) ? result : [result];
      }
    }
    function processMessage(message, options) {
      var len = message.length;
      var result = message[len - 1];
      var path = message.slice(0, len - 1);
      if (path.length === 0) {
        path = [DEFAULT_ERROR_PATH];
      }
      options = xtend(options, { path });
      return typeof result === "function" ? result(options) : formatErrorMessage(options, prettifyResult(result));
    }
    function orList(list) {
      if (list.length < 2) {
        return list[0];
      }
      if (list.length === 2) {
        return list.join(" or ");
      }
      return list.slice(0, -1).join(", ") + ", or " + list.slice(-1);
    }
    function prettifyResult(result) {
      return "must be " + addArticle(result) + ".";
    }
    function addArticle(nounPhrase) {
      if (/^an? /.test(nounPhrase)) {
        return nounPhrase;
      }
      if (/^[aeiou]/i.test(nounPhrase)) {
        return "an " + nounPhrase;
      }
      if (/^[a-z]/i.test(nounPhrase)) {
        return "a " + nounPhrase;
      }
      return nounPhrase;
    }
    function formatErrorMessage(options, prettyResult) {
      var arrayCulprit = isArrayCulprit(options.path);
      var output = options.path.join(".") + " " + prettyResult;
      var prepend = arrayCulprit ? "Item at position " : "";
      return prepend + output;
    }
    function isArrayCulprit(path) {
      return typeof path[path.length - 1] == "number" || typeof path[0] == "number";
    }
    function objectEntries(obj) {
      return Object.keys(obj || {}).map(function(key) {
        return { key, value: obj[key] };
      });
    }
    v.validate = validate;
    v.processMessage = processMessage;
    module.exports = v;
  }
});

// node_modules/base-64/base64.js
var require_base64 = __commonJS({
  "node_modules/base-64/base64.js"(exports, module) {
    (function(root) {
      var freeExports = typeof exports == "object" && exports;
      var freeModule = typeof module == "object" && module && module.exports == freeExports && module;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
      }
      var InvalidCharacterError = function(message) {
        this.message = message;
      };
      InvalidCharacterError.prototype = new Error();
      InvalidCharacterError.prototype.name = "InvalidCharacterError";
      var error = function(message) {
        throw new InvalidCharacterError(message);
      };
      var TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var REGEX_SPACE_CHARACTERS = /[\t\n\f\r ]/g;
      var decode = function(input) {
        input = String(input).replace(REGEX_SPACE_CHARACTERS, "");
        var length = input.length;
        if (length % 4 == 0) {
          input = input.replace(/==?$/, "");
          length = input.length;
        }
        if (length % 4 == 1 || // http://whatwg.org/C#alphanumeric-ascii-characters
        /[^+a-zA-Z0-9/]/.test(input)) {
          error(
            "Invalid character: the string to be decoded is not correctly encoded."
          );
        }
        var bitCounter = 0;
        var bitStorage;
        var buffer;
        var output = "";
        var position = -1;
        while (++position < length) {
          buffer = TABLE.indexOf(input.charAt(position));
          bitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer;
          if (bitCounter++ % 4) {
            output += String.fromCharCode(
              255 & bitStorage >> (-2 * bitCounter & 6)
            );
          }
        }
        return output;
      };
      var encode = function(input) {
        input = String(input);
        if (/[^\0-\xFF]/.test(input)) {
          error(
            "The string to be encoded contains characters outside of the Latin1 range."
          );
        }
        var padding = input.length % 3;
        var output = "";
        var position = -1;
        var a;
        var b;
        var c;
        var d;
        var buffer;
        var length = input.length - padding;
        while (++position < length) {
          a = input.charCodeAt(position) << 16;
          b = input.charCodeAt(++position) << 8;
          c = input.charCodeAt(++position);
          buffer = a + b + c;
          output += TABLE.charAt(buffer >> 18 & 63) + TABLE.charAt(buffer >> 12 & 63) + TABLE.charAt(buffer >> 6 & 63) + TABLE.charAt(buffer & 63);
        }
        if (padding == 2) {
          a = input.charCodeAt(position) << 8;
          b = input.charCodeAt(++position);
          buffer = a + b;
          output += TABLE.charAt(buffer >> 10) + TABLE.charAt(buffer >> 4 & 63) + TABLE.charAt(buffer << 2 & 63) + "=";
        } else if (padding == 1) {
          buffer = input.charCodeAt(position);
          output += TABLE.charAt(buffer >> 2) + TABLE.charAt(buffer << 4 & 63) + "==";
        }
        return output;
      };
      var base64 = {
        "encode": encode,
        "decode": decode,
        "version": "0.1.0"
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define(function() {
          return base64;
        });
      } else if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          freeModule.exports = base64;
        } else {
          for (var key in base64) {
            base64.hasOwnProperty(key) && (freeExports[key] = base64[key]);
          }
        }
      } else {
        root.base64 = base64;
      }
    })(exports);
  }
});

// node_modules/@mapbox/parse-mapbox-token/index.js
var require_parse_mapbox_token = __commonJS({
  "node_modules/@mapbox/parse-mapbox-token/index.js"(exports, module) {
    "use strict";
    var base64 = require_base64();
    var tokenCache = {};
    function parseToken(token) {
      if (tokenCache[token]) {
        return tokenCache[token];
      }
      var parts = token.split(".");
      var usage = parts[0];
      var rawPayload = parts[1];
      if (!rawPayload) {
        throw new Error("Invalid token");
      }
      var parsedPayload = parsePaylod(rawPayload);
      var result = {
        usage,
        user: parsedPayload.u
      };
      if (has(parsedPayload, "a"))
        result.authorization = parsedPayload.a;
      if (has(parsedPayload, "exp"))
        result.expires = parsedPayload.exp * 1e3;
      if (has(parsedPayload, "iat"))
        result.created = parsedPayload.iat * 1e3;
      if (has(parsedPayload, "scopes"))
        result.scopes = parsedPayload.scopes;
      if (has(parsedPayload, "client"))
        result.client = parsedPayload.client;
      if (has(parsedPayload, "ll"))
        result.lastLogin = parsedPayload.ll;
      if (has(parsedPayload, "iu"))
        result.impersonator = parsedPayload.iu;
      tokenCache[token] = result;
      return result;
    }
    function parsePaylod(rawPayload) {
      try {
        return JSON.parse(base64.decode(rawPayload));
      } catch (parseError) {
        throw new Error("Invalid token");
      }
    }
    function has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    module.exports = parseToken;
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter;
    }
  }
});

export {
  require_immutable,
  require_parse_mapbox_token,
  require_eventemitter3,
  require_lib
};
/*! Bundled license information:

base-64/base64.js:
  (*! http://mths.be/base64 v0.1.0 by @mathias | MIT license *)
*/
//# sourceMappingURL=chunk-DOQ7I7SS.js.map
